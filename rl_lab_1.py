# -*- coding: utf-8 -*-
"""RL Lab 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JH8gjjEmevzt5RHS9JZlRmURx_h8hyFw

# Lab 1 
In this notebook, we use the following modules `numpy` and `maze`. The latter is a home made module, where all the solutions to the questions are implemented.
"""

import numpy as np
import maze_lab1 as mz
#import pandas as pd

# Description of the maze as a numpy array
maze = np.array([
    [0, 0, 1, 0, 0, 0, 0],
    [0, 0, 1, 0, 1, 0, 0],
    [0, 0, 1, 0, 1, 1, 1],
    [0, 0, 1, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 1, 0],
    [0, 0, 0, 1, 2, 0, 0]
])

# with the convention 
# 0 = empty cell
# 1 = obstacle
# 2 = exit of the Maze where also the Minotaur starts

mz.draw_maze(maze)

# Description of the weight matrix as a numpy array
w = np.array([
    [-1, -1, -100, -1, -1, -1, -1],
    [-1, -1, -100, -1, -100, -1, -1],
    [-1, -1, -100, -1, -100, -100, -100],
    [-1,-1,-1,-1, -100, -1, -1],
    [-1,-1,-1,-1,-1,-1,-1],
    [-1, -100, -100, -100, -100, -1, -1],
    [-1, -1, -1, -100, -200, -1, -1]
])

# Create an environment maze
#env = mz.Maze(maze, weights=w)
env = mz.Maze(maze)
#env.show()

# Finite horizon
horizon = 20
# Solve the MDP problem with dynamic programming 
V, policy= mz.dynamic_programming(env, horizon);
# Simulate the shortest path starting from position A
method = 'DynProg';
start  = (0,0,6,5);
path = env.simulate(start, policy, method);
for elem in path:
    print(elem)
# Show the shortest path
# this animation only works on ipython notebook
#mz.animate_solution(maze, path)
